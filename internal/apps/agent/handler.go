/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package agent provides Agent distribution and management for the SeaTunnel Control Plane.
// agent 包提供 SeaTunnel Control Plane 的 Agent 分发和管理功能。
package agent

import (
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/gin-gonic/gin"
	"github.com/seatunnel/seatunnelX/internal/config"
	"github.com/seatunnel/seatunnelX/internal/logger"
)

// Handler provides HTTP handlers for Agent distribution operations.
// Handler 提供 Agent 分发操作的 HTTP 处理器。
type Handler struct {
	// controlPlaneAddr is the address of the Control Plane for Agent to connect.
	// controlPlaneAddr 是 Agent 连接的 Control Plane 地址。
	controlPlaneAddr string

	// agentBinaryDir is the directory containing Agent binary files.
	// agentBinaryDir 是包含 Agent 二进制文件的目录。
	agentBinaryDir string

	// grpcPort is the gRPC port for Agent to connect.
	// grpcPort 是 Agent 连接的 gRPC 端口。
	grpcPort string
}

// HandlerConfig holds configuration for the Agent Handler.
// HandlerConfig 保存 Agent Handler 的配置。
type HandlerConfig struct {
	// ControlPlaneAddr is the address of the Control Plane.
	// ControlPlaneAddr 是 Control Plane 的地址。
	ControlPlaneAddr string

	// AgentBinaryDir is the directory containing Agent binary files.
	// AgentBinaryDir 是包含 Agent 二进制文件的目录。
	AgentBinaryDir string

	// GRPCPort is the gRPC port for Agent connections.
	// GRPCPort 是 Agent 连接的 gRPC 端口。
	GRPCPort string
}

// NewHandler creates a new Handler instance.
// NewHandler 创建一个新的 Handler 实例。
func NewHandler(cfg *HandlerConfig) *Handler {
	if cfg == nil {
		cfg = &HandlerConfig{}
	}

	// Set defaults
	// 设置默认值
	if cfg.ControlPlaneAddr == "" {
		cfg.ControlPlaneAddr = config.Config.App.Addr
	}
	if cfg.AgentBinaryDir == "" {
		cfg.AgentBinaryDir = "./lib/agent"
	}
	if cfg.GRPCPort == "" {
		cfg.GRPCPort = "50051"
	}

	return &Handler{
		controlPlaneAddr: cfg.ControlPlaneAddr,
		agentBinaryDir:   cfg.AgentBinaryDir,
		grpcPort:         cfg.GRPCPort,
	}
}

// ==================== Response Types 响应类型 ====================

// ErrorResponse represents an error response.
// ErrorResponse 表示错误响应。
type ErrorResponse struct {
	ErrorMsg string `json:"error_msg"`
}

// ==================== Install Script Handler 安装脚本处理器 ====================

// installScriptTemplate is the template for the Agent install script.
// installScriptTemplate 是 Agent 安装脚本的模板。
// Requirements: 2.1 - Returns shell script with auto-detection logic for OS and architecture.
const installScriptTemplate = `#!/bin/bash
# SeaTunnel Agent Install Script
# SeaTunnel Agent 安装脚本
# Generated by SeaTunnel Control Plane
# 由 SeaTunnel Control Plane 生成

set -e

# Configuration
# 配置
CONTROL_PLANE_ADDR="{{.ControlPlaneAddr}}"
GRPC_ADDR="{{.GRPCAddr}}"
INSTALL_DIR="/usr/local/bin"
CONFIG_DIR="/etc/seatunnelx-agent"
AGENT_BINARY="seatunnelx-agent"
SERVICE_NAME="seatunnelx-agent"

# Colors for output
# 输出颜色
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Cleanup function for error handling
# 错误处理的清理函数
cleanup() {
    log_error "Installation failed. Cleaning up..."
    rm -f "${INSTALL_DIR}/${AGENT_BINARY}" 2>/dev/null || true
    rm -rf "${CONFIG_DIR}" 2>/dev/null || true
    rm -f "/etc/systemd/system/${SERVICE_NAME}.service" 2>/dev/null || true
    systemctl daemon-reload 2>/dev/null || true
    exit 1
}

# Set trap for cleanup on error
# 设置错误时的清理陷阱
trap cleanup ERR

# Detect OS type
# 检测操作系统类型
detect_os() {
    local os_type
    os_type=$(uname -s | tr '[:upper:]' '[:lower:]')
    
    case "${os_type}" in
        linux)
            echo "linux"
            ;;
        darwin)
            echo "darwin"
            ;;
        *)
            log_error "Unsupported operating system: ${os_type}"
            log_error "不支持的操作系统: ${os_type}"
            exit 1
            ;;
    esac
}

# Detect CPU architecture
# 检测 CPU 架构
detect_arch() {
    local arch
    arch=$(uname -m)
    
    case "${arch}" in
        x86_64|amd64)
            echo "amd64"
            ;;
        aarch64|arm64)
            echo "arm64"
            ;;
        *)
            log_error "Unsupported architecture: ${arch}"
            log_error "不支持的架构: ${arch}"
            exit 1
            ;;
    esac
}

# Check if running as root
# 检查是否以 root 身份运行
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        log_error "This script must be run as root"
        log_error "此脚本必须以 root 身份运行"
        exit 1
    fi
}

# Download Agent binary
# 下载 Agent 二进制文件
download_agent() {
    local os_type=$1
    local arch=$2
    local download_url="${CONTROL_PLANE_ADDR}/api/v1/agent/download?os=${os_type}&arch=${arch}"
    local temp_file="/tmp/${AGENT_BINARY}"
    
    log_info "Downloading Agent binary from ${download_url}..."
    log_info "正在从 ${download_url} 下载 Agent 二进制文件..."
    
    if command -v curl &> /dev/null; then
        curl -fsSL -o "${temp_file}" "${download_url}"
    elif command -v wget &> /dev/null; then
        wget -q -O "${temp_file}" "${download_url}"
    else
        log_error "Neither curl nor wget is available"
        log_error "curl 和 wget 都不可用"
        exit 1
    fi
    
    # Verify download
    # 验证下载
    if [ ! -f "${temp_file}" ] || [ ! -s "${temp_file}" ]; then
        log_error "Failed to download Agent binary"
        log_error "下载 Agent 二进制文件失败"
        exit 1
    fi
    
    # Move to install directory
    # 移动到安装目录
    mv "${temp_file}" "${INSTALL_DIR}/${AGENT_BINARY}"
    chmod +x "${INSTALL_DIR}/${AGENT_BINARY}"
    
    log_info "Agent binary installed to ${INSTALL_DIR}/${AGENT_BINARY}"
    log_info "Agent 二进制文件已安装到 ${INSTALL_DIR}/${AGENT_BINARY}"
}

# Create configuration file
# 创建配置文件
create_config() {
    log_info "Creating configuration file..."
    log_info "正在创建配置文件..."
    
    mkdir -p "${CONFIG_DIR}"
    
    cat > "${CONFIG_DIR}/config.yaml" << EOF
# SeaTunnel Agent Configuration
# SeaTunnel Agent 配置

# Control Plane connection settings
# Control Plane 连接设置
control_plane:
  # gRPC address of the Control Plane
  # Control Plane 的 gRPC 地址
  addr: "${GRPC_ADDR}"
  # Enable TLS for gRPC connection
  # 启用 gRPC 连接的 TLS
  tls_enabled: false

# Agent settings
# Agent 设置
agent:
  # Heartbeat interval in seconds
  # 心跳间隔（秒）
  heartbeat_interval: 10
  # Log level (debug, info, warn, error)
  # 日志级别
  log_level: info
  # Log output path
  # 日志输出路径
  log_path: /var/log/seatunnelx-agent/agent.log

# SeaTunnel settings
# SeaTunnel 设置
seatunnel:
  # Default installation directory
  # 默认安装目录
  install_dir: /opt/seatunnel
EOF
    
    log_info "Configuration file created at ${CONFIG_DIR}/config.yaml"
    log_info "配置文件已创建于 ${CONFIG_DIR}/config.yaml"
}

# Create systemd service
# 创建 systemd 服务
create_systemd_service() {
    log_info "Creating systemd service..."
    log_info "正在创建 systemd 服务..."
    
    cat > "/etc/systemd/system/${SERVICE_NAME}.service" << EOF
[Unit]
Description=SeaTunnel Agent Service
Documentation=https://seatunnel.apache.org/
After=network.target

[Service]
Type=simple
User=root
ExecStart=${INSTALL_DIR}/${AGENT_BINARY} --config ${CONFIG_DIR}/config.yaml
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

# Resource limits
# 资源限制
LimitNOFILE=65536
LimitNPROC=65536

[Install]
WantedBy=multi-user.target
EOF
    
    # Reload systemd
    # 重新加载 systemd
    systemctl daemon-reload
    
    # Enable service
    # 启用服务
    systemctl enable "${SERVICE_NAME}"
    
    log_info "Systemd service created and enabled"
    log_info "Systemd 服务已创建并启用"
}

# Start Agent service
# 启动 Agent 服务
start_agent() {
    log_info "Starting Agent service..."
    log_info "正在启动 Agent 服务..."
    
    systemctl start "${SERVICE_NAME}"
    
    # Wait for service to start
    # 等待服务启动
    sleep 3
    
    if systemctl is-active --quiet "${SERVICE_NAME}"; then
        log_info "Agent service started successfully"
        log_info "Agent 服务启动成功"
    else
        log_error "Failed to start Agent service"
        log_error "启动 Agent 服务失败"
        journalctl -u "${SERVICE_NAME}" --no-pager -n 20
        exit 1
    fi
}

# Main installation process
# 主安装流程
main() {
    log_info "=========================================="
    log_info "SeaTunnel Agent Installation Script"
    log_info "SeaTunnel Agent 安装脚本"
    log_info "=========================================="
    
    # Check root
    # 检查 root
    check_root
    
    # Detect OS and architecture
    # 检测操作系统和架构
    local os_type
    local arch
    os_type=$(detect_os)
    arch=$(detect_arch)
    
    log_info "Detected OS: ${os_type}, Architecture: ${arch}"
    log_info "检测到操作系统: ${os_type}, 架构: ${arch}"
    
    # Download Agent
    # 下载 Agent
    download_agent "${os_type}" "${arch}"
    
    # Create configuration
    # 创建配置
    create_config
    
    # Create systemd service
    # 创建 systemd 服务
    create_systemd_service
    
    # Start Agent
    # 启动 Agent
    start_agent
    
    log_info "=========================================="
    log_info "Installation completed successfully!"
    log_info "安装成功完成！"
    log_info "=========================================="
    log_info "Agent is now running and will connect to Control Plane"
    log_info "Agent 正在运行并将连接到 Control Plane"
    log_info ""
    log_info "Useful commands / 常用命令:"
    log_info "  Check status / 检查状态: systemctl status ${SERVICE_NAME}"
    log_info "  View logs / 查看日志: journalctl -u ${SERVICE_NAME} -f"
    log_info "  Restart / 重启: systemctl restart ${SERVICE_NAME}"
    log_info "  Stop / 停止: systemctl stop ${SERVICE_NAME}"
}

# Run main
# 运行主函数
main
`

// installScriptData holds data for the install script template.
// installScriptData 保存安装脚本模板的数据。
type installScriptData struct {
	ControlPlaneAddr string
	GRPCAddr         string
}

// GetInstallScript handles GET /api/v1/agent/install.sh - returns the Agent install script.
// GetInstallScript 处理 GET /api/v1/agent/install.sh - 返回 Agent 安装脚本。
// Requirements: 2.1 - Returns shell script with auto-detection logic for OS and architecture.
// @Tags agent
// @Produce text/x-shellscript
// @Success 200 {string} string "Install script"
// @Router /api/v1/agent/install.sh [get]
func (h *Handler) GetInstallScript(c *gin.Context) {
	// Parse template
	// 解析模板
	tmpl, err := template.New("install").Parse(installScriptTemplate)
	if err != nil {
		logger.ErrorF(c.Request.Context(), "[Agent] Failed to parse install script template: %v", err)
		c.JSON(http.StatusInternalServerError, ErrorResponse{ErrorMsg: "Failed to generate install script / 生成安装脚本失败"})
		return
	}

	// Prepare template data
	// 准备模板数据
	data := installScriptData{
		ControlPlaneAddr: h.getControlPlaneURL(),
		GRPCAddr:         h.getGRPCAddr(),
	}

	// Set content type for shell script
	// 设置 shell 脚本的内容类型
	c.Header("Content-Type", "text/x-shellscript; charset=utf-8")
	c.Header("Content-Disposition", "attachment; filename=install.sh")

	// Execute template and write to response
	// 执行模板并写入响应
	if err := tmpl.Execute(c.Writer, data); err != nil {
		logger.ErrorF(c.Request.Context(), "[Agent] Failed to execute install script template: %v", err)
		return
	}
}

// ==================== Download Handler 下载处理器 ====================

// supportedArchitectures defines the supported OS and architecture combinations.
// supportedArchitectures 定义支持的操作系统和架构组合。
var supportedArchitectures = map[string]map[string]string{
	"linux": {
		"amd64": "agent-linux-amd64",
		"arm64": "agent-linux-arm64",
	},
	"darwin": {
		"amd64": "agent-darwin-amd64",
		"arm64": "agent-darwin-arm64",
	},
}

// DownloadAgent handles GET /api/v1/agent/download - downloads the Agent binary.
// DownloadAgent 处理 GET /api/v1/agent/download - 下载 Agent 二进制文件。
// Requirements: 2.2 - Downloads Agent binary for the specified OS and architecture.
// @Tags agent
// @Param os query string true "Operating system (linux, darwin)"
// @Param arch query string true "CPU architecture (amd64, arm64)"
// @Produce application/octet-stream
// @Success 200 {file} binary "Agent binary file"
// @Failure 400 {object} ErrorResponse "Invalid parameters"
// @Failure 404 {object} ErrorResponse "Binary not found"
// @Router /api/v1/agent/download [get]
func (h *Handler) DownloadAgent(c *gin.Context) {
	// Get query parameters
	// 获取查询参数
	osType := strings.ToLower(c.Query("os"))
	arch := strings.ToLower(c.Query("arch"))

	// Validate parameters
	// 验证参数
	if osType == "" || arch == "" {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			ErrorMsg: "Missing required parameters: os and arch / 缺少必需参数: os 和 arch",
		})
		return
	}

	// Check if OS is supported
	// 检查操作系统是否支持
	archMap, osSupported := supportedArchitectures[osType]
	if !osSupported {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			ErrorMsg: fmt.Sprintf("Unsupported operating system: %s. Supported: linux, darwin / 不支持的操作系统: %s. 支持: linux, darwin", osType, osType),
		})
		return
	}

	// Check if architecture is supported
	// 检查架构是否支持
	binaryName, archSupported := archMap[arch]
	if !archSupported {
		c.JSON(http.StatusBadRequest, ErrorResponse{
			ErrorMsg: fmt.Sprintf("Unsupported architecture: %s. Supported: amd64, arm64 / 不支持的架构: %s. 支持: amd64, arm64", arch, arch),
		})
		return
	}

	// Build binary path
	// 构建二进制文件路径
	binaryPath := filepath.Join(h.agentBinaryDir, binaryName)

	// Check if binary exists
	// 检查二进制文件是否存在
	if _, err := os.Stat(binaryPath); os.IsNotExist(err) {
		logger.WarnF(c.Request.Context(), "[Agent] Binary not found: %s", binaryPath)
		c.JSON(http.StatusNotFound, ErrorResponse{
			ErrorMsg: fmt.Sprintf("Agent binary not found for %s-%s. Please contact administrator / 未找到 %s-%s 的 Agent 二进制文件，请联系管理员", osType, arch, osType, arch),
		})
		return
	}

	// Set headers for binary download
	// 设置二进制下载的头信息
	c.Header("Content-Type", "application/octet-stream")
	c.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", binaryName))

	// Serve the file
	// 提供文件
	c.File(binaryPath)

	logger.InfoF(c.Request.Context(), "[Agent] Binary downloaded: %s-%s", osType, arch)
}

// ==================== Helper Methods 辅助方法 ====================

// getControlPlaneURL returns the full URL of the Control Plane.
// getControlPlaneURL 返回 Control Plane 的完整 URL。
func (h *Handler) getControlPlaneURL() string {
	addr := h.controlPlaneAddr
	if addr == "" {
		addr = "localhost:8080"
	}

	// Add http:// prefix if not present
	// 如果没有 http:// 前缀则添加
	if !strings.HasPrefix(addr, "http://") && !strings.HasPrefix(addr, "https://") {
		addr = "http://" + addr
	}

	return addr
}

// getGRPCAddr returns the gRPC address for Agent connection.
// getGRPCAddr 返回 Agent 连接的 gRPC 地址。
func (h *Handler) getGRPCAddr() string {
	// Extract host from control plane address
	// 从 Control Plane 地址提取主机
	addr := h.controlPlaneAddr
	addr = strings.TrimPrefix(addr, "http://")
	addr = strings.TrimPrefix(addr, "https://")

	// Remove port if present
	// 如果存在端口则移除
	if idx := strings.Index(addr, ":"); idx != -1 {
		addr = addr[:idx]
	}

	// Add gRPC port
	// 添加 gRPC 端口
	return fmt.Sprintf("%s:%s", addr, h.grpcPort)
}
